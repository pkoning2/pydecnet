PyDECnet uses JSON over HTTPS for its API.  It uses the GET method to
retrieve information, and POST to make a request or change something.

The API uses URLs starting with /api, followed by additional path
elements to indicate what specifically is to be read or operated on.

If a GET is done with a URL consisting only of /api, a dictionary of
systems is returned, with the system name as key and a short
description of what the system is as the value.  For example:

{
   "ERNIE" : [
      "Area router",
      "1.2"
   ],
   "br-0" : "Bridge"
}

For any other request, if there are multiple systems in this PyDECnet
process (as in the example shown) the system to operate on must be
named by a URL argument such as "?system=ERNIE".

The next URL path component after /api indicates which top level
component to access.  Valid values are: mop, routing, bridge.  The
requests supported by each component are given below.

API for MOP

GET request for MOP

A GET of /api/mop returns basic information about this MOP, in
particular the circuits (data links) it handles.  For example:

{
   "circuits" : [
      "ETH-102"
   ]
}

GET requests for a specific MOP data link

GET /api/mop/<circuitname> returns information about that circuit.
For example:

{
   "name" : "ETH-102",
   "macaddr" : "52-99-bc-a7-67-89",
   "services" : [
      "loop"
   ]
}

GET /api/mop/<circuitname>/sysid returns the current contents of the
SysID message listener for that circuit.  This is only valid for
Ethernet circuits.  The return value is a list of entries, each of
which is a dictionary with keys naming the SysID message fields.  For
example:
[
   {
      "processor" : "Communication Server",
      "reservation_timer" : 0,
      "device" : "PCL11-B UNIBUS multiple CPU link",
      "datalink" : "CSMA-CD",
      "carrier" : 0,
      "hwaddr" : "ce-e6-14-13-4f-11",
      "console_user" : "",
      "software" : "DECnet/Python",
      "srcaddr" : "ce-e6-14-13-4f-11"
   }
]

GET /api/mop/<circuitname>/console

This requests any pending console carrier output.  It is only valid if
issued by the client that currently has the console carrier reserved.
The cookie created by the POST that began the session must be
included.  The reply is the current output as a string, possibly empty
if there is no current output.

POST requests for MOP

MOP allows the following POST requests, addressed to a specific
circuit, which must be Ethernet:

POST /api/mop/<circuitname>/loop

This requests an Ethernet loop operation.  The POST data is a JSON
encoded dictionary carrying the request parameters:

<TBD>

The reply reports the result of each of the loop requests transmitted,
for example:

<TBD>

POST /api/mop/<circuitname>/console

This begins, continues, or terminates a console carrier session.  To
continue or terminate a session, the cookie returned by the request to
begin the session must be included.  For the request to begin a
session, the POST data is a JSON encoded dictionary carrying the
request parameters:

<TBD>

To continue a console carrier session, the POST data is a JSON encoded
dictionary with these parameters:

<TBD>

To terminate a console carrier session, the POST data is empty.

The reply includes a cookie to represent the session for begin and
continue, and omits the cookie to indicate the session is closed for
terminate.   The reply data is a JSON encoded dictionary reporting the
result of the operation, for example:

POST /api/mop/<circuitname>/sysid

This operation issues a MOP Request Counters message to a station on
the specified Ethernet.  (This is addressed to the "sysid" entity
because the operation is handled by the Sysid processing element.) The
request data is a JSON encoded dictionary specifying the request
parameters:

{
  "dest" : "f2-63-1f-8d-f8-94",
  "timeout" : 2
}

Timeout is an optional timeout for the request, in seconds.  Default
is 5 seconds.

The reply is a JSON encoded dictionary reporting the counters obtained
from the station, or an error status indicating failure to obtain the
information.  For example:

{
   "status" : "timeout"
}

or

{
   "pkts_sent" : 0,
   "bytes_sent" : 0,
   "ctr_zero_time" : 65535,
   "unk_dest" : 0,
   "bytes_recd" : 0,
   "mcpkts_recd" : 0,
   "mcbytes_recd" : 0,
   "status" : "ok",
   "pkts_recd" : 0
}

API for Routing

GET for routing

A GET request to routing returns some basic information about the
DECnet node, and a list of circuit names.  For example:

{
   "version" : "2.0.0",
   "circuits" : [
      "MUL-0",
      "ETH-102"
   ],
   "name" : "ERNIE",
   "type" : "Area router",
   "address" : 1026
}

Note that the node address (here and elsewhere in the API) is an
integer.  For phase II and III, that is the node number, but for Phase
IV it is the node and area number in the usual form (area number in
the upper 6 bits of the 16 bit value).  Sending it as an integer is
intended to simplify processing by the API caller.

GET requests for a specific Routing circuit

A GET request addressed to a routing circuit returns information about
that circuit.  The information returned depends on whether the circuit
is point to point (such as DDCMP) or a LAN circuit (Ethernet).

Example of point to point circuit response:

{
   "hello_timer" : 60,
   "listen_timer" : 120,
   "cost" : 1,
   "state" : "ru",
   "blocksize" : 576,
   "type" : "Area router",
   "neighbor" : 2049,
   "version" : "2.0.0",
   "name" : "MUL-0"
}

For a LAN circuit, the response includes a list of adjacencies, each
of which gives a dictionary of attributes for that particular
adjacency.  For example:

{
   "name" : "ETH-102",
   "cost" : 1,
   "priority" : 64,
   "is_dr" : true,
   "hello_timer" : 10,
   "adjacencies" : [
      {
         "priority" : 64,
         "type" : "Area router",
         "neighbor" : 2049,
         "version" : "2.0.0",
         "blocksize" : 591
      }
   ]
}

API for Bridge

<TBD>
