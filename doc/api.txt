PyDECnet uses JSON over HTTPS for its API.  It uses the GET method to
retrieve information, and POST to make a request or change something.

Responses and POST request data are encoded using JSON.  For fields
that contain byte string data (such as packet contents), these are
sent as strings, interpreted as Latin-1 text which means each
character encodes the corresponding byte value.

Node addresses are encoded as an integer.  For phase II and III, that
is the node number; for Phase IV it is the combined node and area
number in the usual form (area number in the upper 6 bits of the 16
bit value).  MAC addresses (Ethernet addresses) are encoded as
strings, 6 hex byte fields separated by hyphens in the usual
representation used by DEC (not colons as is used in some other
conventions).  For example: "2a-f1-0d-7b-4e-95" or
"aa-00-04-00-0b-08".  Similarly, Ethernet protocol types are encoded
as strings, 2 hex byte fields, for example "60-03".

Note that dictionary fields in the replies are not in any particular
order (since that does not affect the meaning).  Similarly, unless
stated otherwise, lists entries are not in a specific order.

The API uses URLs starting with /api, followed by additional path
elements to indicate what specifically is to be read or operated on.

If a GET is done with a URL consisting only of /api, a dictionary of
systems is returned, with the system name as key and a short
description of what the system is as the value.  For example:

{
   "ERNIE" : [
      "Area router",
      1026
   ],
   "br-0" : "Bridge"
}

For any other request, if there are multiple systems in this PyDECnet
process (as in the example shown) the system to operate on must be
named by a URL argument such as "?system=ERNIE".  The system name is
case insensitive.

The next URL path component after /api indicates which top level
component to access.  Valid values are: mop, routing, bridge.  The
requests supported by each component are given below.

API for MOP

GET request for MOP

A GET of /api/mop returns basic information about this MOP, in
particular the circuits (data links) it handles.  For example:

{
   "circuits" : [
      "ETH-102"
   ]
}

GET requests for a specific MOP data link

GET /api/mop/<circuitname> returns information about that circuit.
For example:

{
   "name" : "ETH-102",
   "macaddr" : "52-99-bc-a7-67-89",
   "services" : [
      "loop"
   ]
}

GET /api/mop/<circuitname>/sysid returns the current contents of the
SysID message listener for that circuit.  This is only valid for
Ethernet circuits.  The return value is a list of entries, each of
which is a dictionary with keys naming the SysID message fields.  For
example:
[
   {
      "processor" : "Communication Server",
      "reservation_timer" : 0,
      "device" : "PCL11-B UNIBUS multiple CPU link",
      "datalink" : "CSMA-CD",
      "carrier" : 0,
      "hwaddr" : "ce-e6-14-13-4f-11",
      "console_user" : "",
      "software" : "DECnet/Python",
      "srcaddr" : "ce-e6-14-13-4f-11"
   }
]

GET /api/mop/<circuitname>/console

This requests any pending console carrier output.  It is only valid if
issued by the client that currently has the console carrier reserved.
The cookie created by the POST that began the session must be
included.  The reply is the current output as a string, possibly empty
if there is no current output.

POST requests for MOP

MOP allows the following POST requests, addressed to a specific
circuit, which must be Ethernet:

POST /api/mop/<circuitname>/loop

This requests an Ethernet loop operation.  The POST data is a JSON
encoded dictionary carrying the request parameters:

<TBD>

The reply reports the result of each of the loop requests transmitted,
for example:

<TBD>

POST /api/mop/<circuitname>/console

This begins, continues, or terminates a console carrier session.  To
continue or terminate a session, the cookie returned by the request to
begin the session must be included.  For the request to begin a
session, the POST data is a JSON encoded dictionary carrying the
request parameters:

<TBD>

To continue a console carrier session, the POST data is a JSON encoded
dictionary with these parameters:

<TBD>

To terminate a console carrier session, the POST data is empty.

The reply includes a cookie to represent the session for begin and
continue, and omits the cookie to indicate the session is closed for
terminate.   The reply data is a JSON encoded dictionary reporting the
result of the operation, for example:

POST /api/mop/<circuitname>/sysid

This operation issues a MOP Request Counters message to a station on
the specified Ethernet.  (This is addressed to the "sysid" entity
because the operation is handled by the Sysid processing element.) The
request data is a JSON encoded dictionary specifying the request
parameters:

{
  "dest" : "f2-63-1f-8d-f8-94",
  "timeout" : 2
}

Timeout is an optional timeout for the request, in seconds.  Default
is 5 seconds.

The reply is a JSON encoded dictionary reporting the counters obtained
from the station, or an error status indicating failure to obtain the
information.  For example:

{
   "status" : "timeout"
}

or

{
   "pkts_sent" : 0,
   "bytes_sent" : 0,
   "ctr_zero_time" : 65535,
   "unk_dest" : 0,
   "bytes_recd" : 0,
   "mcpkts_recd" : 0,
   "mcbytes_recd" : 0,
   "status" : "ok",
   "pkts_recd" : 0
}

API for Routing

GET for routing

A GET request to routing returns some basic information about the
DECnet node, and a list of circuit names.  For example:

{
   "version" : "2.0.0",
   "circuits" : [
      "MUL-0",
      "ETH-102"
   ],
   "name" : "ERNIE",
   "type" : "Area router",
   "address" : 1026
}

GET requests for a specific Routing circuit

A GET request addressed to a routing circuit returns information about
that circuit.  The information returned depends on whether the circuit
is point to point (such as DDCMP) or a LAN circuit (Ethernet).

Example of point to point circuit response:

{
   "hello_timer" : 60,
   "listen_timer" : 120,
   "cost" : 1,
   "state" : "ru",
   "blocksize" : 576,
   "type" : "Area router",
   "neighbor" : 2049,
   "version" : "2.0.0",
   "name" : "MUL-0"
}

For a LAN circuit on a router, the response includes a list of
adjacencies, each of which gives a dictionary of attributes for that
particular adjacency.  For example:

{
   "name" : "ETH-102",
   "cost" : 1,
   "priority" : 64,
   "is_dr" : true,
   "designated_router" : 2049
   "hello_timer" : 10,
   "adjacencies" : [
      {
         "priority" : 64,
         "type" : "Area router",
         "neighbor" : 2049,
         "listen_timer" : 30,
         "version" : "2.0.0",
         "blocksize" : 591
      }
   ]
}

For a LAN circuit on an end node, the response shows the current
designated router, if known.  For example:

{
   "name" : "ETH-102",
   "hello_timer" : 10,
   "designated_router" : {
      "type" : "Area router",
      "version" : "2.0.0",
      "blocksize" : 591,
      "priority" : 64,
      "neighbor" : 2049,
      "listen_timer" : 30
   }
}

API for Bridge

A GET request for the bridge returns the bridge name and a list of
circuits, for example:

{
   "name" : "br-0",
   "circuits" : [
      "ETH-42",
      "ETH-43"
   ]
}

A GET request for a bridge circuit returns the name of the circuit and
the list of Ethernet protocol types enabled for bridging on that
circuit, for example:

{
   "name" : "ETH-43",
   "protocols" : [
      "90-00",
      "60-04",
      "60-01",
      "60-02",
      "60-03"
   ]
}

A GET request to bridge/addrdb returns the address database
(forwarding database) of the bridge, in the form of a dictionary keyed
by destination MAC address with the circuit to forward to as the
value.  For example:

{
   "aa-00-04-00-01-08" : "ETH-43",
   "aa-00-04-00-0b-08" : "ETH-42"
}
